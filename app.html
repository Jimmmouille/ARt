<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Stencil AR ‚Äì Viewer v2.0</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000}
#loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-family:system-ui;text-align:center;z-index:100}
#instructions{position:fixed;top:12px;right:12px;padding:16px;background:rgba(0,0,0,.8);border-radius:12px;color:#fff;font-family:system-ui;font-size:13px;line-height:1.6;max-width:280px;z-index:10;backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.1)}
#instructions h3{margin:0 0 8px;color:#36a2ff;font-size:15px}
#instructions ul{margin:0;padding-left:20px;list-style:none}
#instructions li{margin:4px 0;color:#d3d8de}
#instructions li::before{content:"‚ñ∏ ";color:#36a2ff;margin-right:4px}
#instructions .key{color:#ffd700;font-weight:600}
</style>
</head>
<body>
<div id="loading"><h2>üé® Stencil AR v2.0</h2><p>Chargement...</p></div>

<div id="instructions">
  <h3>Commandes VR</h3>
  <ul>
    <li><span class="key">Joystick ‚¨ÜÔ∏è‚¨áÔ∏è</span> Zoom (0.1x-20x)</li>
    <li><span class="key">Joystick ‚¨ÖÔ∏è‚û°Ô∏è</span> Opacit√©</li>
    <li><span class="key">Joystick 2 ‚¨ÜÔ∏è‚¨áÔ∏è</span> Profondeur</li>
    <li><span class="key">Trigger</span> Repositionner</li>
    <li><span class="key">A/X</span> Masquer image</li>
    <li><span class="key">B/Y</span> Masquer aide</li>
  </ul>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.147.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.147.0/examples/jsm/webxr/ARButton.js';

const DB_NAME = 'stencil-db';
const STORE = 'images';
const KEY = 'current';

let currentScale = 1.0;
let currentOpacity = 1.0;
let currentDepth = 0;
let group = null;
let mesh = null;
let currentObjectURL = null;
let clock = new THREE.Clock();
let previousDidPressHideImage = false;
let previousDidPressHideInstructions = false;
const instructionsEl = document.getElementById('instructions');

function openDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbGet(key){
  const db = await openDB();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readonly');
    const store = tx.objectStore(STORE);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.xr.setFoveation(0);
document.body.appendChild(renderer.domElement);

document.body.appendChild(ARButton.createButton(renderer, { 
  requiredFeatures:['local-floor'],
  optionalFeatures:['hand-tracking', 'depth-sensing']
}));

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);

const light = new THREE.HemisphereLight(0xffffff,0x222233,1.0);
scene.add(light);

group = new THREE.Group();
group.position.set(0, 0, -0.5);
scene.add(group);

const controller1 = renderer.xr.getController(0);
scene.add(controller1);

const controller2 = renderer.xr.getController(1);
scene.add(controller2);

async function loadTextureFromIndexedDB(){
  const record = await idbGet(KEY);
  if(!record || !record.blob){
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#667eea'; 
    ctx.fillRect(0,0,512,256);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 32px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Stencil AR v2.0', 256, 100);
    ctx.font = '16px system-ui';
    ctx.fillText('Chargez une image depuis l\'accueil', 256, 140);
    return { texture: new THREE.CanvasTexture(canvas), width: 2, height: 1 };
  }
  if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL = null; }
  const url = URL.createObjectURL(record.blob);
  currentObjectURL = url;
  return new Promise((resolve)=>{
    const loader = new THREE.TextureLoader();
    loader.load(url, (tex)=>{
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = true;
      resolve({ texture: tex, width: record.width || (tex.image?.width||1), height: record.height || (tex.image?.height||1) });
    }, undefined, ()=>{
      const canvas = document.createElement('canvas');
      canvas.width = 2; canvas.height = 2;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,2,2);
      resolve({ texture: new THREE.CanvasTexture(canvas), width: 1, height: 1 });
    });
  });
}

async function createOrUpdateMesh(){
  const { texture: tex, width, height } = await loadTextureFromIndexedDB();
  const aspect = width && height ? width/height : 1;
  const h = 0.25;
  const w = h * aspect;
  const geom = new THREE.PlaneGeometry(w, h);
  const mat = new THREE.MeshBasicMaterial({ 
    map: tex, 
    transparent: true, 
    opacity: currentOpacity,
    side: THREE.DoubleSide 
  });
  if(mesh){
    group.remove(mesh);
    mesh.geometry.dispose();
    if(mesh.material.map) mesh.material.map.dispose();
    mesh.material.dispose();
  }
  mesh = new THREE.Mesh(geom, mat);
  mesh.renderOrder = 1;
  group.add(mesh);
  group.scale.set(currentScale, currentScale, currentScale);
  
  setTimeout(() => {
    const loading = document.getElementById('loading');
    if (loading) loading.style.display = 'none';
  }, 500);
}

function incrementScale(delta){
  currentScale += delta;
  currentScale = Math.min(Math.max(currentScale, 0.1), 20.0);
  if(group){
    group.scale.set(currentScale, currentScale, currentScale);
  }
}

function incrementOpacity(delta){
  currentOpacity += delta;
  currentOpacity = Math.min(Math.max(currentOpacity, 0.0), 1.0);
  if(mesh){
    mesh.material.opacity = currentOpacity;
  }
}

function incrementDepth(delta){
  currentDepth += delta;
  currentDepth = Math.min(Math.max(currentDepth, -5.0), 5.0);
  if(group){
    const baseZ = -0.5;
    group.position.z = baseZ + currentDepth;
  }
}

await createOrUpdateMesh();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight; 
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function updateFromControllers(){
  const session = renderer.xr.getSession();
  if(!session) return;
  
  const elapsedTime = clock.getDelta();
  let didPressHideImage = false;
  let didPressHideInstructions = false;

  for(let i = 0; i < session.inputSources.length; i++){
    const source = session.inputSources[i];
    if(!source.gamepad) continue;
    
    const gamepad = source.gamepad;
    const axes = gamepad.axes || [];
    const buttons = gamepad.buttons || [];
    
    // Distinguer manette gauche et droite
    if(source.handedness === 'left' && axes.length >= 2){
      // Manette gauche : contr√¥le de profondeur (avancer/reculer)
      const vertical = axes[1]; // Axe Y du joystick gauche
      
      if(vertical < -0.7){
        incrementDepth(-1.0 * elapsedTime); // Joystick vers le haut = reculer
      } else if(vertical > 0.7){
        incrementDepth(1.0 * elapsedTime); // Joystick vers le bas = avancer
      }
    } else if(source.handedness === 'right' && axes.length >= 2){
      // Manette droite : contr√¥les de zoom et opacit√©
      const horizontal = axes[0]; // Axe X du joystick droit
      const vertical = axes[1];   // Axe Y du joystick droit
      
      // Zoom avec joystick vertical
      if(vertical < -0.7){
        incrementScale(1.0 * elapsedTime); // Joystick vers le haut = zoom in
      } else if(vertical > 0.7){
        incrementScale(-1.0 * elapsedTime); // Joystick vers le bas = zoom out
      }
      
      // Opacit√© avec joystick horizontal
      if(horizontal > 0.7){
        incrementOpacity(1.0 * elapsedTime); // Joystick vers la droite = plus opaque
      } else if(horizontal < -0.7){
        incrementOpacity(-1.0 * elapsedTime); // Joystick vers la gauche = plus transparent
      }
    }
    
    // Boutons (fonctionnent sur les deux manettes)
    if(buttons.length > 0 && buttons[0].pressed){
      // Trigger : repositionner l'image
      const controllerToUse = renderer.xr.getController(i);
      const offsetPosition = controllerToUse.localToWorld(new THREE.Vector3(0, 0, 0.045));
      group.position.copy(offsetPosition);
      group.setRotationFromQuaternion(controllerToUse.quaternion);
      currentDepth = 0;
    }
    
    if(buttons.length > 4 && buttons[4].pressed){
      // Bouton A/X : masquer/afficher l'image
      didPressHideImage = true;
    }
    
    if(buttons.length > 5 && buttons[5].pressed){
      // Bouton B/Y : masquer/afficher l'aide
      didPressHideInstructions = true;
    }
  }
  
  const shouldChangeInstructionsVisibility = (!didPressHideInstructions && previousDidPressHideInstructions);
  previousDidPressHideInstructions = didPressHideInstructions;
  
  if(shouldChangeInstructionsVisibility && instructionsEl){
    instructionsEl.style.display = instructionsEl.style.display === 'none' ? 'block' : 'none';
  }
  
  const shouldChangeImageVisibility = (!didPressHideImage && previousDidPressHideImage);
  previousDidPressHideImage = didPressHideImage;
  
  if(shouldChangeImageVisibility && mesh){
    mesh.visible = !mesh.visible;
  }
}

renderer.setAnimationLoop(()=>{
  updateFromControllers();
  renderer.render(scene, camera);
});
</script>
</body>
</html>
