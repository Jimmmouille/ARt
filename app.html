<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Stencil AR - Viewer v2.0</title>
    <style>
        body { 
            margin: 0; 
            background-color: #000;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            text-align: center;
            z-index: 100;
        }

        .loading h2 {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <h2>ðŸŽ¨ Stencil AR v2.0</h2>
        <p>Chargement...</p>
    </div>

    <div id="container"></div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.147.0/examples/jsm/",
            "three-mesh-ui": "https://unpkg.com/three-mesh-ui@6.5.2/build/three-mesh-ui.module.js"
        }
    }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader">
    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
    uniform sampler2D colorTexture;
    uniform float opacity;
    float stepSize = 2.0;

    varying vec2 vUv;

    float intensity(in vec4 color) {
        return sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));
    }

    void main() {
        vec2 uv = vUv;
        
        ivec2 imageSize = textureSize(colorTexture, 0);
        vec2 step = vec2(stepSize/float(imageSize.x), stepSize/float(imageSize.y));

        float topLeft     = intensity(texture2D(colorTexture, uv + vec2(-step.x, step.y)));
        float left        = intensity(texture2D(colorTexture, uv + vec2(-step.x, 0)));
        float bottomLeft  = intensity(texture2D(colorTexture, uv + vec2(-step.x, -step.y)));
        float top         = intensity(texture2D(colorTexture, uv + vec2(0, step.y)));
        float bottom      = intensity(texture2D(colorTexture, uv + vec2(0, -step.y)));
        float topRight    = intensity(texture2D(colorTexture, uv + vec2(step.x, step.y)));
        float right       = intensity(texture2D(colorTexture, uv + vec2(step.x, 0)));
        float bottomRight = intensity(texture2D(colorTexture, uv + vec2(step.x, -step.y)));
     
        float horizontal = topLeft + 2.0 * left + bottomLeft - topRight - 2.0 * right - bottomRight;
        float vertical = -topLeft - 2.0 * top - topRight + bottomLeft + 2.0 * bottom + bottomRight;

        float sobelResult = sqrt(horizontal * horizontal + vertical * vertical);

        vec4 sobelColor = vec4(1.0 - sobelResult, 1.0 - sobelResult, 1.0 - sobelResult, sobelResult);
        vec4 currentColor = texture2D(colorTexture, uv);

        float smoothOpacity = smoothstep(0.0, 0.3, opacity);

        gl_FragColor = vec4(
            currentColor.x * smoothOpacity + (1.0 - smoothOpacity) * sobelColor.x,
            currentColor.y * smoothOpacity + (1.0 - smoothOpacity) * sobelColor.y,
            currentColor.z * smoothOpacity + (1.0 - smoothOpacity) * sobelColor.z,
            currentColor.w * min(opacity, smoothOpacity) + (1.0 - smoothOpacity) * sobelColor.w
        );
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import ThreeMeshUI from 'three-mesh-ui';

    const DB_NAME = 'stencil-db';
    const STORE = 'images';
    const KEY = 'current';

    let container;
    let camera, scene, renderer;
    let clock;
    let group = null;
    let imagePlane = null;
    let instructionsPlane = null;
    let currentOpacity = 0.75;
    let currentScale = 1.0;
    let currentDepth = -0.5;
    let previousDidPressHideImage = false;
    let previousDidPressHideInstructions = false;
    let currentObjectURL = null;

    function openDB(){
        return new Promise((resolve, reject)=>{
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = () => {
                const db = req.result;
                if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }

    async function idbGet(key){
        const db = await openDB();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(STORE, 'readonly');
            const store = tx.objectStore(STORE);
            const req = store.get(key);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => reject(req.error);
        });
    }

    init();
    animate();

    function init() {
        container = document.getElementById("container");
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
        camera.position.set(0, 0, 1);

        const controls = new OrbitControls(camera, container);
        controls.minDistance = 0;
        controls.maxDistance = 8;

        clock = new THREE.Clock();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.xr.enabled = true;
        renderer.xr.setFoveation(0);
        container.appendChild(renderer.domElement);

        const controller1 = renderer.xr.getController(0);
        scene.add(controller1);

        const controller2 = renderer.xr.getController(1);
        scene.add(controller2);

        makeInstructionsUI();

        const length = 0.25;
        group = new THREE.Group();
        group.position.set(0, 0, currentDepth);
        scene.add(group);

        loadImageFromIndexedDB(group, length);

        window.addEventListener('resize', onWindowResize);

        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) loading.style.display = 'none';
        }, 1000);
    }

    function makeInstructionsUI() {
        const textContainer = new ThreeMeshUI.Block({
            borderRadius: 0.05,
            width: 0.50,
            height: 0.75,
            padding: 0.05,
            textAlign: 'left',
            fontKerning: 'none',
            whiteSpace: 'pre-wrap',
            fontFamily: 'https://unpkg.com/three-mesh-ui@6.5.2/examples/assets/Roboto-msdf.json',
            fontTexture: 'https://unpkg.com/three-mesh-ui@6.5.2/examples/assets/Roboto-msdf.png'
        });

        textContainer.rotation.y = -45.0 * (Math.PI / 180.0);
        textContainer.position.set(0.5, 0, -0.5);

        textContainer.add(
            new ThreeMeshUI.Text({
                content: "Instructions AR v2.0\n",
                fontSize: 0.04,
                fontColor: new THREE.Color(0x667eea)
            }),

            new ThreeMeshUI.Text({
                content: "\nJoystick droite: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "OpacitÃ© +",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\nJoystick gauche: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "OpacitÃ© -",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\n\nJoystick haut: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Agrandir (zoom 20x)",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\nJoystick bas: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "RÃ©duire",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\n\nJoystick avant (2Ã¨me): ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Rapprocher",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\nJoystick arriÃ¨re (2Ã¨me): ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Ã‰loigner",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\n\nTrigger (maintenir): ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Repositionner",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\n\nA ou X: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Masquer/Afficher image",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            }),

            new ThreeMeshUI.Text({
                content: "\nB ou Y: ",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffd700)
            }),
            new ThreeMeshUI.Text({
                content: "Masquer/Afficher aide",
                fontSize: 0.025,
                fontColor: new THREE.Color(0xffffff)
            })
        );

        scene.add(textContainer);
        instructionsPlane = textContainer;
    }

    async function loadImageFromIndexedDB(container, length) {
        const record = await idbGet(KEY);
        
        if (!record || !record.blob) {
            generatePlaceholderAndLoad(container, length);
            return;
        }

        if(currentObjectURL){ 
            URL.revokeObjectURL(currentObjectURL); 
            currentObjectURL = null; 
        }
        
        const url = URL.createObjectURL(record.blob);
        currentObjectURL = url;
        loadTextureFromDataUrl(container, length, url);
    }

    function generatePlaceholderAndLoad(container, length) {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#667eea';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 64px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Stencil AR v2.0', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '32px system-ui';
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillText('Chargez une image depuis l\'accueil', canvas.width / 2, canvas.height / 2 + 32);
        
        const dataUrl = canvas.toDataURL('image/png');
        loadTextureFromDataUrl(container, length, dataUrl);
    }

    function loadTextureFromDataUrl(container, length, dataUrl) {
        const img = new Image();
        img.onload = () => {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            texture.generateMipmaps = false;

            document.body.appendChild(ARButton.createButton(renderer, {
                requiredFeatures: ['local-floor'],
                optionalFeatures: ['hand-tracking', 'depth-sensing']
            }));

            let originalWidth = img.width;
            let originalHeight = img.height;

            let max = Math.max(originalWidth, originalHeight);
            let width = (originalWidth / max) * length;
            let height = (originalHeight / max) * length;

            const geometry = new THREE.PlaneGeometry(width, height);

            const sobelMaterial = new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.DoubleSide,
                uniforms: {
                    colorTexture: { value: texture },
                    opacity: { value: currentOpacity }
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent
            });

            imagePlane = new THREE.Mesh(geometry, sobelMaterial);
            container.add(imagePlane);
        };
        img.src = dataUrl;
    }

    function incrementOpacity(delta) {
        currentOpacity += delta;
        currentOpacity = Math.min(Math.max(currentOpacity, 0.0), 1.0);

        if (imagePlane != null) {
            imagePlane.material.uniforms["opacity"].value = currentOpacity;
        }
    }

    function incrementScale(delta) {
        currentScale += delta;
        currentScale = Math.min(Math.max(currentScale, 0.1), 20.0);

        if (group != null) {
            group.scale.set(currentScale, currentScale, currentScale);
        }
    }

    function incrementDepth(delta) {
        currentDepth += delta;
        currentDepth = Math.min(Math.max(currentDepth, -5.0), 2.0);

        if (group != null) {
            group.position.z = currentDepth;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        renderer.setAnimationLoop(loop);
    }

    function loop() {
        updateInput();
        ThreeMeshUI.update();
        renderer.render(scene, camera);
    }

    function updateInput() {
        const xrSession = renderer.xr.getSession();
        const elapsedTime = clock.getDelta();

        let didPressHideImage = false;
        let didPressHideInstructions = false;

        if (xrSession == null || xrSession.inputSources.length <= 0) {
            return;
        }

        for (let i = 0; i < xrSession.inputSources.length; i++) {
            const input = xrSession.inputSources[i];
            const gamepad = input.gamepad;

            if (gamepad != null && gamepad.mapping == "xr-standard" && gamepad.axes.length >= 4) {
                const horizontalRight = gamepad.axes[2];
                const verticalRight = gamepad.axes[3];
                const horizontalLeft = gamepad.axes[0];
                const verticalLeft = gamepad.axes[1];

                const triggerButton = gamepad.buttons[0];
                const axButton = gamepad.buttons[4];
                const byButton = gamepad.buttons[5];

                if (verticalRight < -0.7) {
                    incrementScale(1.0 * elapsedTime);
                } else if (verticalRight > 0.7) {
                    incrementScale(-1.0 * elapsedTime);
                }

                if (horizontalRight > 0.7) {
                    incrementOpacity(1.0 * elapsedTime);
                } else if (horizontalRight < -0.7) {
                    incrementOpacity(-1.0 * elapsedTime);
                }

                if (verticalLeft < -0.7) {
                    incrementDepth(-1.0 * elapsedTime);
                } else if (verticalLeft > 0.7) {
                    incrementDepth(1.0 * elapsedTime);
                }

                const controllerToUse = renderer.xr.getController(i);

                if (triggerButton.pressed) {
                    const offsetPosition = controllerToUse.localToWorld(new THREE.Vector3(0, 0, 0.045));
                    group.position.copy(offsetPosition);
                    group.setRotationFromQuaternion(controllerToUse.quaternion);
                }

                if (axButton.pressed) {
                    didPressHideImage = true;
                }

                if (byButton.pressed) {
                    didPressHideInstructions = true;
                }
            }
        }

        const shouldChangeInstructionsVisibility = (!didPressHideInstructions && previousDidPressHideInstructions);
        previousDidPressHideInstructions = didPressHideInstructions;

        if (shouldChangeInstructionsVisibility && instructionsPlane) {
            instructionsPlane.visible = !instructionsPlane.visible;
        }

        const shouldChangeImageVisibility = (!didPressHideImage && previousDidPressHideImage);
        previousDidPressHideImage = didPressHideImage;

        if (shouldChangeImageVisibility && imagePlane) {
            imagePlane.visible = !imagePlane.visible;
        }
    }
    </script>
</body>
</html>
